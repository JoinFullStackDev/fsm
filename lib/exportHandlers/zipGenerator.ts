import JSZip from 'jszip';
import type { BlueprintBundle } from './blueprint';

/**
 * Generate a ZIP file for Blueprint Bundle with proper folder structure
 */
export async function generateBlueprintZip(bundle: BlueprintBundle, projectName: string): Promise<Blob> {
  const zip = new JSZip();

  // Sanitize project name for folder/file names
  const sanitizedName = projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

  // Create folder structure
  const conceptFolder = zip.folder('concept');
  const strategyFolder = zip.folder('strategy');
  const prototypeFolder = zip.folder('prototype');
  const analysisFolder = zip.folder('analysis');
  const buildFolder = zip.folder('build');
  const qaFolder = zip.folder('qa');

  // Concept files
  conceptFolder?.file('concept_summary.md', bundle.concept.concept_summary);
  conceptFolder?.file('rac_summary.md', bundle.concept.rac_summary);
  conceptFolder?.file('high_level_feasibility.md', bundle.concept.high_level_feasibility);

  // Strategy files
  strategyFolder?.file('personas.json', JSON.stringify(bundle.strategy.personas, null, 2));
  strategyFolder?.file('outcomes_and_kpis.md', bundle.strategy.outcomes_and_kpis);
  strategyFolder?.file('feature_backlog.json', JSON.stringify(bundle.strategy.feature_backlog, null, 2));
  strategyFolder?.file('outcome_roadmap.md', bundle.strategy.outcome_roadmap);

  // Prototype files
  prototypeFolder?.file('screens.json', JSON.stringify(bundle.prototype.screens, null, 2));
  prototypeFolder?.file('flows.json', JSON.stringify(bundle.prototype.flows, null, 2));
  prototypeFolder?.file('components.json', JSON.stringify(bundle.prototype.components, null, 2));
  prototypeFolder?.file('design_tokens.json', JSON.stringify(bundle.prototype.design_tokens, null, 2));
  prototypeFolder?.file('navigation_map.md', bundle.prototype.navigation_map);

  // Analysis files
  analysisFolder?.file('erd.json', JSON.stringify(bundle.analysis.erd, null, 2));
  analysisFolder?.file('apis.json', JSON.stringify(bundle.analysis.apis, null, 2));
  analysisFolder?.file('user_stories.json', JSON.stringify(bundle.analysis.user_stories, null, 2));
  analysisFolder?.file('acceptance_criteria.json', JSON.stringify(bundle.analysis.acceptance_criteria, null, 2));
  analysisFolder?.file('rbac_matrix.json', JSON.stringify(bundle.analysis.rbac_matrix, null, 2));
  analysisFolder?.file('non_functional_requirements.md', bundle.analysis.non_functional_requirements);

  // Build files
  buildFolder?.file('folder_structure.txt', bundle.build.folder_structure);
  buildFolder?.file('architecture_instructions.md', bundle.build.architecture_instructions);
  buildFolder?.file('coding_standards.md', bundle.build.coding_standards);
  buildFolder?.file('env_setup.md', bundle.build.env_setup);

  // QA files
  qaFolder?.file('test_plan.md', bundle.qa.test_plan);
  qaFolder?.file('test_cases.json', JSON.stringify(bundle.qa.test_cases, null, 2));
  qaFolder?.file('security_checklist.md', bundle.qa.security_checklist.join('\n'));
  qaFolder?.file('performance_requirements.md', bundle.qa.performance_requirements);
  qaFolder?.file('launch_readiness.md', bundle.qa.launch_readiness.join('\n'));

  // Add README
  const readme = `# ${bundle.project.name} - Blueprint Bundle

Generated by FullStack Method™ App

## Project Information

- **Name**: ${bundle.project.name}
- **Description**: ${bundle.project.description}
- **Status**: ${bundle.project.status}
- **Primary Tool**: ${bundle.project.primary_tool || 'Not specified'}

## Folder Structure

- \`concept/\` - Concept framing documents
- \`strategy/\` - Product strategy and personas
- \`prototype/\` - UI/UX prototype definitions
- \`analysis/\` - Technical analysis and specifications
- \`build/\` - Build instructions and standards
- \`qa/\` - Quality assurance and testing

## Usage

This blueprint bundle contains all the structured information needed to build the application. Use the files in each folder as reference when implementing features.

Generated: ${new Date().toISOString()}
`;

  zip.file('README.md', readme);

  // Generate ZIP file
  const blob = await zip.generateAsync({ type: 'blob' });
  return blob;
}

/**
 * Generate a ZIP file for Cursor Bundle with proper folder structure
 */
export async function generateCursorZip(cursorPrompt: string, projectName: string): Promise<Blob> {
  const zip = new JSZip();

  // Sanitize project name for folder/file names
  const sanitizedName = projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

  // Create folder structure
  const docsFolder = zip.folder('docs');
  const specsFolder = zip.folder('specs');

  // Main cursor master prompt
  zip.file('cursor_master_prompt.txt', cursorPrompt);

  // Parse cursor prompt to extract structured data (if needed)
  // For now, we'll create a structured version
  docsFolder?.file('project_overview.md', extractProjectOverview(cursorPrompt));
  docsFolder?.file('tech_stack.md', extractTechStack(cursorPrompt));
  
  specsFolder?.file('api_specs.md', extractAPISpecs(cursorPrompt));
  specsFolder?.file('user_stories.md', extractUserStories(cursorPrompt));
  specsFolder?.file('acceptance_criteria.md', extractAcceptanceCriteria(cursorPrompt));

  // Add README
  const readme = `# ${projectName} - Cursor Master Prompt Bundle

Generated by FullStack Method™ App

## Contents

- \`cursor_master_prompt.txt\` - Complete master prompt for Cursor AI
- \`docs/\` - Project documentation
- \`specs/\` - Technical specifications

## Usage

1. Copy the contents of \`cursor_master_prompt.txt\` into Cursor
2. Use the files in \`docs/\` and \`specs/\` as reference
3. Follow the instructions in the master prompt to scaffold your application

Generated: ${new Date().toISOString()}
`;

  zip.file('README.md', readme);

  // Generate ZIP file
  const blob = await zip.generateAsync({ type: 'blob' });
  return blob;
}

// Helper functions to extract sections from cursor prompt
function extractProjectOverview(prompt: string): string {
  const match = prompt.match(/PROJECT SUMMARY\s*\n\n([\s\S]*?)(?=\n\n⸻|\n\nFOLDER STRUCTURE)/);
  return match ? match[1].trim() : 'Project overview not found in prompt';
}

function extractTechStack(prompt: string): string {
  const match = prompt.match(/Tech Stack Requirements\s*\n\n([\s\S]*?)(?=\n\n⸻)/);
  return match ? match[1].trim() : 'Tech stack not found in prompt';
}

function extractAPISpecs(prompt: string): string {
  const match = prompt.match(/API SPECIFICATIONS\s*\n\n([\s\S]*?)(?=\n\n⸻)/);
  return match ? match[1].trim() : 'API specifications not found in prompt';
}

function extractUserStories(prompt: string): string {
  const match = prompt.match(/USER STORIES\s*\n\n([\s\S]*?)(?=\n\n⸻)/);
  return match ? match[1].trim() : 'User stories not found in prompt';
}

function extractAcceptanceCriteria(prompt: string): string {
  const match = prompt.match(/ACCEPTANCE CRITERIA\s*\n\n([\s\S]*?)(?=\n\n⸻)/);
  return match ? match[1].trim() : 'Acceptance criteria not found in prompt';
}

