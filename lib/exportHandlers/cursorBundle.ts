import type {
  Phase1Data,
  Phase2Data,
  Phase3Data,
  Phase4Data,
  Phase5Data,
  Phase6Data,
} from '@/types/phases';
import type { Project } from '@/types/project';

export function generateCursorMasterPrompt(
  project: Project,
  phases: {
    phase1?: Phase1Data;
    phase2?: Phase2Data;
    phase3?: Phase3Data;
    phase4?: Phase4Data;
    phase5?: Phase5Data;
    phase6?: Phase6Data;
  }
): string {
  const phase1 = phases.phase1 || ({} as Phase1Data);
  const phase2 = phases.phase2 || ({} as Phase2Data);
  const phase3 = phases.phase3 || ({} as Phase3Data);
  const phase4 = phases.phase4 || ({} as Phase4Data);
  const phase5 = phases.phase5 || ({} as Phase5Data);
  const phase6 = phases.phase6 || ({} as Phase6Data);

  const prompt = `✅ CURSOR MASTER PROMPT — ${project.name.toUpperCase()}

Version: 1.0
Generated by: FullStack Method™ App

⸻

TOP-LEVEL INSTRUCTIONS

You are building a production-grade web application called "${project.name}", based on the specifications provided below.

This app will be built using the following enforced tech stack:

Tech Stack Requirements

• Next.js (App Router)
• React + TypeScript
• Material UI (MUI) as the component library
• Supabase for:
  • Auth
  • Database (PostgreSQL)
  • Server-side operations (if needed)
  • File storage (optional)
• Node.js 18+ runtime
• Tailwind is NOT used. shadcn is NOT used.
• The design system is Material UI only.

⸻

PROJECT SUMMARY

${project.description || 'No description provided'}

Problem Statement:
${phase1.problem_statement || 'Not defined'}

Target Users:
${phase1.target_users?.join(', ') || 'Not defined'}

Value Hypothesis:
${phase1.value_hypothesis || 'Not defined'}

⸻

FOLDER STRUCTURE

${phase5.folder_structure || 'Use standard Next.js App Router structure'}

⸻

ARCHITECTURE INSTRUCTIONS

${phase5.architecture_instructions || 'Follow Next.js App Router best practices'}

⸻

CODING STANDARDS

${phase5.coding_standards || 'Use TypeScript, React hooks, and follow separation of concerns'}

⸻

ENVIRONMENT SETUP

${phase5.env_setup || 'Standard Next.js environment setup required'}

⸻

ENTITIES & DATA MODELS

${phase4.entities?.map(e => `
Entity: ${e.name}
Description: ${e.description}
Key Fields: ${e.key_fields.join(', ')}
Relationships: ${e.relationships.join(', ')}
`).join('\n') || 'No entities defined'}

ERD Structure:
${JSON.stringify(phase4.erd || {}, null, 2)}

⸻

API SPECIFICATIONS

${phase4.api_spec?.map(api => `
Endpoint: ${api.endpoint}
Method: ${api.method}
Path: ${api.path}
Description: ${api.description}
Request Params: ${JSON.stringify(api.request_params, null, 2)}
Body Schema: ${JSON.stringify(api.body_schema, null, 2)}
Response Schema: ${JSON.stringify(api.response_schema, null, 2)}
Error Codes: ${api.error_codes.join(', ')}
`).join('\n---\n') || 'No API specifications defined'}

⸻

SCREENS

${phase3.screens?.map(screen => `
Screen Key: ${screen.screen_key}
Title: ${screen.title}
Description: ${screen.description}
Roles: ${screen.roles.join(', ')}
Is Core: ${screen.is_core}
`).join('\n---\n') || 'No screens defined'}

⸻

USER FLOWS

${phase3.flows?.map(flow => `
Flow: ${flow.name}
Start Screen: ${flow.start_screen}
End Screen: ${flow.end_screen}
Steps:
${flow.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}
Notes: ${flow.notes}
`).join('\n---\n') || 'No flows defined'}

⸻

COMPONENTS

${phase3.components?.map(comp => `
Component: ${comp.name}
Description: ${comp.description}
Props: ${JSON.stringify(comp.props, null, 2)}
State Behavior: ${comp.state_behavior}
Used On: ${comp.used_on.join(', ')}
`).join('\n---\n') || 'No components defined'}

⸻

DESIGN TOKENS

${JSON.stringify(phase3.design_tokens || {}, null, 2)}

⸻

NAVIGATION

Primary Navigation: ${phase3.navigation?.primary_nav?.join(', ') || 'Not defined'}
Secondary Navigation: ${phase3.navigation?.secondary_nav?.join(', ') || 'Not defined'}
Route Map: ${JSON.stringify(phase3.navigation?.route_map || {}, null, 2)}

⸻

USER STORIES

${phase4.user_stories?.map(story => `
As a ${story.user_role}, ${story.statement}
`).join('\n') || 'No user stories defined'}

⸻

ACCEPTANCE CRITERIA

${phase4.acceptance_criteria?.map(criteria => `
Story ID: ${criteria.story_id}
Given: ${criteria.given}
When: ${criteria.when}
Then: ${criteria.then}
`).join('\n---\n') || 'No acceptance criteria defined'}

⸻

RBAC MATRIX

${JSON.stringify(phase4.rbac || {}, null, 2)}

⸻

NON-FUNCTIONAL REQUIREMENTS

${phase4.non_functional_requirements || 'Not defined'}

⸻

TEST PLAN

${phase6.test_plan || 'Not defined'}

Test Cases:
${phase6.test_cases?.map(tc => `
Test: ${tc.name}
Type: ${tc.type}
Description: ${tc.description}
Steps:
${tc.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}
Expected Result: ${tc.expected_result}
`).join('\n---\n') || 'No test cases defined'}

⸻

SECURITY CHECKLIST

${phase6.security_checklist?.map(item => `- ${item}`).join('\n') || 'No security checklist items'}

⸻

PERFORMANCE REQUIREMENTS

${phase6.performance_requirements || 'Not defined'}

⸻

LAUNCH READINESS

${phase6.launch_readiness?.map(item => `- ${item}`).join('\n') || 'No launch readiness items'}

⸻

FINAL INSTRUCTIONS TO CURSOR

Begin by scaffolding the folder structure and core pages first:
1. Supabase client configuration
2. Authentication pages
3. Main application pages
4. API routes
5. Components

After scaffolding, proceed to building out features according to the user stories and acceptance criteria.

Always reference this prompt as the single source of truth.
`;

  return prompt;
}

